- extrage elementul (adica textmarkup) de la un anumit index in text - DONE

- add a contains children method - DONE
- insert/remove after/before an element - DONE


- getChildrenOfType
- split an element after an index


- test pt. skeletonItem getDefinition

- Contains face pe equals nu pe deep equals... nu poate face prob. pe viitor asta?











There are some utilities methods to perform a conversion between a BCMDocument and a JSON string (ex. from file):
1. To convert from a JSON string to a BCM document you can use: 
	Document document = BCMSerializer.deserializeBCM(jsonString);
	
	There is also a similar version that takes as a parameter an array of bytes, that represents the actul json bytes:
	byte[] jsonByteArray = ....
	Document document = BCMSerializer.deserializeBCM(jsonByteArray);
	
2. To convert from a BCM document to a JSON string, you can use:
	String jsonDocument = BCMSerializer.serializeBCM(documentObject);
	
	We also have a similar method that can be used with any other BCM elements type (ex. paragraph, segment etc.). It takes as an argument an object
	String segmentString = BCMSerializer.deserializeBCM(segmentObject);
	
	
Model manipulation:
	There are new ways of manipulating a model content with all kinds of elements for all kinds of containers. This is done with the help of insertXXX methods that are applicable to all kinds of markup data container elements:
	Example: Suppose we have the segment object 'segment'. To modify it's structure we can use the following:
	
	 TagPair tagPair = new TagPair();
	 tagPair.addMetadata();
	 segment.insertContainer(new int[] {2}, new int[] {8}, tagPair);
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	BCM Model examples
For example we have a segment that contains only the text: 'Simple testing text.'. Let's say we want to add a new TagPair container (based on the string text), on the testing word only. To insert a container (ex. TagPair) inside another container (ex. Segment), we must use the text offsets of the text we want to wrap, for example, for the testing word the offsets are 7 and 14;
Since version 2.6 this can be achieved in the following manner:
// We will programmatically create the above scenario
Segment segment = new Segment();
segment.addChild(new TextMarkup("Simple testing text.")); // add the simple text inside the segment
  
 
TagPair newTagPair = new TagPair();
newTagPair.setTagPairDefinitionId(12); // skeleton tag pair definition
try {
    segment.insertContainer(new int[] {7}, new int[] {14}, newTagPair); // adds the new tag pair container between the given offsets.
} catch (VisitorException e) {
    logger.error(e.getMessage());
}
The JSON format of the above code sample will be (the output was trimed):
 
Original Segment output
1
2
3
4
5
6
7
{
    "type": "segment",
    "children": [{
        "type": "text",
        "text": "Simple testing text."
    }]
}
 
 
After the insertion
{
    "type": "segment",
    "children": [{
        "type": "text",
        "text": "Simple "
    },
    {
        "type": "tagPair",
        "children": [{
            "type": "text",
            "text": "testing"
        }],
        "tagPairDefinitionId": 12,
    },
    {
        "type": "text",
        "text": " text."
    }],
}
 
Conclusions:
The tag pair container was inserted between the given offsets, splitting the initial text markup in three parts: the first and the third part are still direct children of the segment, while the second part (the text between the offsets) has become a child of the new container that was added.