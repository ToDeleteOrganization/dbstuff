package com.sdl.bcm.model;

import com.fasterxml.jackson.annotation.JsonBackReference;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.sdl.bcm.manager.Utils;
import com.sdl.bcm.model.fileskeleton.FileSkeleton;
import com.sdl.bcm.visitor.BCMCompositeElement;
import com.sdl.bcm.visitor.BCMElement;
import com.sdl.bcm.visitor.BCMVisitor;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.builder.EqualsBuilder;
import org.springframework.data.annotation.Transient;

import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Translation data model support that holds file data.
 * A file within a document, usually corresponding to a physical file
 * within the document in the original format, or when the document
 * was a result of merging multiple files together.
 */
@JsonPropertyOrder({"id", "commentDefinitionIds", "skeleton", "paragraphUnits"})
public class File extends MetaData implements BCMCompositeElement<Document, ParagraphUnit> {

    /**
     * Globally unique id of the file.
     * This is generated by the BCM service.
     */
    private String id;

    @Transient
    @JsonBackReference
    private Document parentDocument;

    /**
     * List ParagraphUnit objects associated to current File containing segmented data to be translated.
     * This field is transient and wonâ€™t be serialized.
     * Thus, this field is lost upon saving to Mongo or upon serialization to JSON to clients request.
     */
    @JsonManagedReference
    private List<ParagraphUnit> paragraphUnits;

    /**
     * Transient list of ParagraphUnits from which are excluded structure Paragraph Units
     */
    @Transient
    @JsonIgnore
    private transient List<ParagraphUnit> regularParagraphUnits;

    /**
     * ParagraphUnit map that is used for lookup operations
     */
    @Transient
    @JsonIgnore
    private transient Map<String, ParagraphUnit> paragraphUnitsMap;

    /**
     * The original file name (without path) of the file from which this content was generated.
     * Can be used when serializing the content to a file.
     */
    private String originalFileName;
    /**
     * The id of the file type, which is a specific configuration of a filter.
     */
    private String fileTypeDefinitionId;

    /**
     * The original encoding of the native source language file from which the content originates
     */
    private String originalEncoding;
    /**
     * If set, indicates the preferred code-page that the target language file should be in.
     * This property can be used during editing to warn the user when they try to use
     * characters in the translation that are not supported by the given codepage.
     * If this property is set when writing the target language version of the file,
     * it may be used by the native file writer
     * (though it is ultimately up to the file writer to decide).
     */
    private String preferredTargetEncoding;

    /**
     * FileSkeleton object associated with this File.
     */
    private FileSkeleton skeleton;

    private List<DependencyFile> dependencyFiles;

    private List<Integer> commentDefinitionIds;

    public File() {
       this(null);
    }

	private File(Document parent) {
		paragraphUnits = new LinkedList<>();
		commentDefinitionIds = new LinkedList<>();
		regularParagraphUnits = new LinkedList<>();
		paragraphUnitsMap = new ConcurrentHashMap<>();
		this.parentDocument = parent;
	}
    
    //================= File ID
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    //================= Parent document
    public Document getParentDocument() {
        return parentDocument;
    }

    public void setParentDocument(Document parentDocument) {
        this.parentDocument = parentDocument;
    }

    /**
     * {@inheritDoc}
     * <br />
     * 
     * For a <i>File</i> element, this works the same as {@link #getParentDocument()}.
     * <br />
     * 
     */
	@Override
	public Document getParent() {
		return parentDocument;
	}

    /**
     * {@inheritDoc}
     * <br />
     * 
     * For a <i>File</i> element, this works the same as {@link #getParagraphUnits()}.
     * <br />
     * 
     * @return A list with all paragraph units contained by this <i>File</i>.
     */
	@Override
	@JsonIgnore
	public List<ParagraphUnit> getChildren() {
		 return paragraphUnits;
	}

    public String getOriginalFileName() {
        return originalFileName;
    }

    public void setOriginalFileName(String originalFileName) {
        this.originalFileName = originalFileName;
    }

    public String getFileTypeDefinitionId() {
        return fileTypeDefinitionId;
    }

    public void setFileTypeDefinitionId(String fileTypeDefinitionId) {
        this.fileTypeDefinitionId = fileTypeDefinitionId;
    }

    public String getOriginalEncoding() {
        return originalEncoding;
    }

    public void setOriginalEncoding(String originalEncoding) {
        this.originalEncoding = originalEncoding;
    }

    public String getPreferredTargetEncoding() {
        return preferredTargetEncoding;
    }

    public void setPreferredTargetEncoding(String preferredTargetEncoding) {
        this.preferredTargetEncoding = preferredTargetEncoding;
    }

    //================= ParagraphUnits
    public void addParagraphUnit(ParagraphUnit paragraphUnit) {
        paragraphUnits.add(paragraphUnit);
        if(paragraphUnit.getId() != null)
            paragraphUnitsMap.put(paragraphUnit.getId(), paragraphUnit);
        paragraphUnit.setParentFileId(id);
        paragraphUnit.setParentFile(this);
        if (!paragraphUnit.isStructure()) {
            regularParagraphUnits.add(paragraphUnit);
        }
    }

    public void addParagraphUnit(int index, ParagraphUnit paragraphUnit) {
        paragraphUnits.add(index, paragraphUnit);
        if(paragraphUnit.getId() != null)
            paragraphUnitsMap.put(paragraphUnit.getId(), paragraphUnit);
        paragraphUnit.setParentFileId(id);
    }

    public void updateParagraphUnit(ParagraphUnit paragraphUnit) {
        if(paragraphUnit.getId() != null)
            paragraphUnitsMap.put(paragraphUnit.getId(), paragraphUnit);
        paragraphUnit.setParentFileId(id);
    }

    public ParagraphUnit getParagraph(String paragraphUUID) {
        return paragraphUnitsMap.get(paragraphUUID);
    }

    public List<ParagraphUnit> getParagraphUnits(int startParagraph, int endParagraph, boolean includeStructureParagraph) {
        int start = startParagraph < 0 ? 0 : startParagraph;
        int end = endParagraph > paragraphUnits.size() ? paragraphUnits.size() : endParagraph;

        if (includeStructureParagraph) {
            return paragraphUnits.subList(start, end);
        } else {
            return regularParagraphUnits.subList(start, end);
        }
    }

    public boolean containsParagraphUnit(ParagraphUnit paragraphUnit) {
        return paragraphUnitsMap.containsKey(paragraphUnit.getId());
    }

    @JsonIgnore
    public int getRegularParagraphUnitCount() {
        return regularParagraphUnits.size();
    }

    public List<DependencyFile> getDependencyFiles() {
        return dependencyFiles;
    }

    public void setDependencyFiles(List<DependencyFile> dependencyFiles) {
        this.dependencyFiles = dependencyFiles;
    }

    public void addDependencyFile(DependencyFile dependencyFile) {
        if (dependencyFiles == null) {
            dependencyFiles = new LinkedList<>();
        }
        dependencyFiles.add(dependencyFile);
    }

    public List<Integer> getCommentDefinitionIds() {
        return commentDefinitionIds;
    }

    public void setCommentDefinitionIds(List<Integer> commentDefinitionIds) {
        this.commentDefinitionIds = commentDefinitionIds;
    }

    @Override
    public boolean accept(BCMVisitor visitor) {
        if (visitor.visitEnter(this)) {
            for (BCMElement elementChild : getParagraphUnits()) {
                if (!elementChild.accept(visitor)) {
                    break;
                }
            }
        }
        return visitor.visitLeave(this);
    }

    public FileSkeleton getSkeleton() {
        return skeleton;
    }

    public void setSkeleton(FileSkeleton skeleton) {
        this.skeleton = skeleton;
    }

    public List<ParagraphUnit> getParagraphUnits() {
        return paragraphUnits;
    }

    @Override
	public void copyPropertiesTo(MetaData clone) {
    	File file = super.convertType(clone);
		if (file != null) {
			super.copyPropertiesTo(file);
			file.setId(id);
			file.setOriginalFileName(originalFileName);
			file.setFileTypeDefinitionId(fileTypeDefinitionId);
			file.setOriginalEncoding(originalEncoding);
			file.setPreferredTargetEncoding(preferredTargetEncoding);
			file.setSkeleton(skeleton.deepClone());
			if (!regularParagraphUnits.isEmpty()) {
				file.regularParagraphUnits = new LinkedList<>(regularParagraphUnits);
			}
			if (!MapUtils.isEmpty(paragraphUnitsMap)) {
				file.paragraphUnitsMap = new ConcurrentHashMap<>(paragraphUnitsMap);
			}
			if (!CollectionUtils.isEmpty(dependencyFiles)) {
				file.setDependencyFiles(Utils.deepCloneList(dependencyFiles));
			}
			if (!CollectionUtils.isEmpty(commentDefinitionIds)) {
				file.commentDefinitionIds = new LinkedList<>(commentDefinitionIds);
			}
		}
    }

    @Override
    public File deepClone() {
    	File file = new File(parentDocument);
    	copyPropertiesTo(file);
    	file.paragraphUnits = Utils.deepCloneList(paragraphUnits);
    	return file;
    }

    @Override
    public boolean equals(Object o) {
        if( ! super.equals(o))
            return false;
        File that = (File) o;
        return new EqualsBuilder()
                .append(id, that.id)
                .append(originalEncoding, that.originalEncoding)
                .append(preferredTargetEncoding, that.preferredTargetEncoding)
                .append(originalFileName, that.originalFileName)
                .append(fileTypeDefinitionId, that.fileTypeDefinitionId)
                .append(dependencyFiles, that.dependencyFiles)
                .append(commentDefinitionIds, that.commentDefinitionIds)
                .append(skeleton, that.skeleton)
                .isEquals();
    }

    @Override
    public boolean deepEquals(Object o) {
        if(! this.equals(o))
            return false;
        File file = (File) o;
        return Utils.deepEqualsCollection(paragraphUnits, file.getParagraphUnits());
    }

    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (id != null ? id.hashCode() : 0);
        result = 31 * result + (originalEncoding != null ? originalEncoding.hashCode() : 0);
        result = 31 * result + (preferredTargetEncoding != null ? preferredTargetEncoding.hashCode() : 0);
        result = 31 * result + (originalFileName != null ? originalFileName.hashCode() : 0);
        result = 31 * result + (fileTypeDefinitionId != null ? fileTypeDefinitionId.hashCode() : 0);
        result = 31 * result + (dependencyFiles != null ? dependencyFiles.hashCode() : 0);
        result = 31 * result + (commentDefinitionIds != null ? commentDefinitionIds.hashCode() : 0);
        result = 31 * result + (skeleton != null ? skeleton.hashCode() : 0);
        return result;
    }

}
